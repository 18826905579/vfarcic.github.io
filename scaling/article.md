The History of Failed Initiatives
=================================

I started my career as a developer. During those early days all I knew (and thought I should know) was to write code. I though that a great developer is a person that is proficient in writing code and that the path to the mastery of the craft was to know everything about a single programming language of choice. Later on that changed and I started taking interest in different programming languages. I switched from Pascal to Basic and then ASP. When Java and, later on, .Net came into existence, I learned benefits of object oriented programming. Python, Perl, Bash, HTML, JavaScript, Scala... Each programming language brought something new and though me how to think differently and how to pick the right tool for the task at hand. With each new language I learned, I felt like I was closer to being an expert. All I wanted was to become a senior programmer. That desire changed with time. I learned that if I was to do my job well, I had to become __software craftsman__. I had to learn much more than to type code. Testing became my obsession for some time and now I consider it an integral part of development. Except in very special cases, each line of code I write is done with __test-driven development (TDD)__. It become indispensable part of my tool-belt. I also learned that I had to be close to the customer and work with him side by side while defining what should be done. All that, and many other things, lead me to __software architecture__. Understanding the "big picture" and trying to fit different pieces into one big system was the challenge that I learned to like.


Throughout all the years I've been working in software industry, there was no single tool, framework or practice that I admired more than __continuous integration (CI)__ (and later on __continuous delivery (CD))__. The true meaning of that statement hides behind the scope of what CI/CD envelops. At the beginning, I though that CI/CD means that I knew __Jenkins__ and was able to write scripts. As the time passed and I got more and more involved and learned that CI/CD is related to almost every aspect of software development. That knowledge came at a cost. I failed (more than once) to create a successful CI pipeline with applications I worked with at the time. Even though others considered the end result a success, now I know that it was a failure because the approach I took was wrong. CI/CD cannot be done without making architectural decisions. Similar can be said for tests, configurations, environments, fail-over, etc. In order to create a successful implementation of CI/CD, we need to make a lot of changes that, on the first look, do not seem to be directly related. We need to apply some patterns and practices from the very beginning. We have to think about architecture, testing, coupling, packaging, fault tolerance, and many other things. CI/CD requires us to influence almost every aspect of software development. That diversity is what made me fall in love with it. By practicing CI/CD we are effectively influencing and improving almost every aspect of the software development life cycle.

In order to be truly proficient with CI/CD we need to be much more than experts in operations. DevOps movement was a big improvement that combined traditional operations with advantages that development could bring. I think that is not enough. We need to know and influence architecture, testing, development, operations and even customer negotiations if we want to gain all the benefits that CI/CD can bring. Even the name DevOps as the driving force behind the CI/CD is not adequate since it's not only about development and operations but about everything related to software development. It should also include architects, testers and even managers. DevOps was a great improvement when compared to the traditional operations in sense that it combined development. The movement understood that manually running operations is not an option given current business demands and that there is no automation without development. I think that the time came to redefine DevOps by extending its scope. Since the name __DevOpsArcTestManageAndEverythingElse__ is too cumbersome to remember and close to impossible to pronounce, I opt for **DevOps 2.0**. It's the next generation that should drop the cumbersome do-it-all products in favour of smaller tools designed to do very specific tasks. It's the switch that should go back to the beginning and not only make sure that operations are automated but that the whole system is designed in the way that it can be automated, fast, scalable, fault tolerant, with zero-downtime, easy to monitor, and so on. We cannot accomplish this by simply automating manual procedures and employing a single do-it-all tool. We need to go much deeper than that and start refactoring the whole system both on technological as well as procedural level.